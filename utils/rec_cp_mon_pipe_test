#!/usr/bin/env bash
################################################################################
# Test objective: check if a receive copy monitor receives frames when its
#                 monitored netmap pipe is receiving, even if the monitored pipe
#                 hasn't yet read the frame.
# Operations:
# 0) restart fd_server to have a clean starting state
# 1) create a pair of netmap pipes (pipe{1, pipe}1).
# 2) open a receive copy monitor pipe{1/r for pipe{1.
# 3) send from pipe}1 and don't read from pipe{1, check that pipe{1/r receives
#    the frame.
# 4) receive from pipe{1.
################################################################################
source test_lib

parse_send_recv_arguments "$@"
fill="${fill:-d}"
len="${len:-150}"
num="${num:-1}"

restart_fd_server

# Pre-opening interface that will be needed. This is needed to avoid a race
# condition between the sending and receiving ports.
./functional -i "netmap:pipe{1"   &>/dev/null
check_exit $? "pre-open netmap:pipe{1"
./functional -i "netmap:pipe{1/r" &>/dev/null
check_exit $? "pre-open netmap:pipe{1/r"
./functional -i "netmap:pipe}1"   &>/dev/null
check_exit $? "pre-open netmap:pipe}1"

# First we send without reading from pipe{1
./functional -i "netmap:pipe{1/r" -r "${len}:${fill}:${num}" &>/dev/null &
p1=$!
./functional -i "netmap:pipe}1"   -t "${len}:${fill}:${num}" &>/dev/null
e2=$?
wait $p1
e1=$?
check_exit $e1 "receive-${num} netmap:pipe{1/r"
check_exit $e2 "send-${num} netmap:pipe}1"

# Then we read from pipe{1
./functional -i "netmap:pipe{1"   -r "${len}:${fill}:${num}" &>/dev/null
e3=$?
check_exit $e3 "receive-${num} netmap:pipe{1"

echo "Test successful."