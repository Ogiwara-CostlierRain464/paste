#!/usr/bin/env bash
################################################################################
# Test objective: check if a zero-copy monitor is correctly blocked until the
#                 monitored VALE port reads the frame.
# Operations:
# 0) restart fd_server to have a clean starting state
# 1) create a persistent VALE port (v0).
# 2) connect v0 and a VALE ephimeral port (v1) to the same VALE switch (vale0).
# 3) open a zero-copy monitor v0/z for v0.
# 4) send from v1 without receiving from v0, check that v0/z doesn't receive the
#    rame.
# 5) receive from v0, check that v0/z receives the frame.
################################################################################
source test_lib

restart_fd_server

create_vale_persistent_port "v0" "vale0"
# Pre-opening interface that will be needed. This is needed to avoid a race
# condition between the sending and receiving ports.
./functional -i "vale0:v0"   &>/dev/null
check_exit $? "pre-open vale0:v0"
./functional -i "vale0:v0/z" &>/dev/null
check_exit $? "pre-open vale0:v0/z"
./functional -i "vale0:v1"   &>/dev/null
check_exit $? "pre-open vale0:v1"

fill='d'
len=150
num=1
# Initially we don't receive with the monitored VALE port v0, therefore the
# monitor should not receive the frame.
./functional -i vale0:v0/z -r "${len}:${fill}:${num}" -n &>/dev/null &
p1=$!
./functional -i vale0:v1   -t "${len}:${fill}:${num}"    &>/dev/null
e2=$?
wait $p1
e1=$?
check_exit $e1 "no-receive-${num} vale0:v0/z"
check_exit $e2 "send-${num} vale0:v0"

# Now we receive with the monitored VALE port v0, therefore the monitor should
# receive the frame.
./functional -i "vale0:v0"   -r "${len}:${fill}:${num}" &>/dev/null &
p3=$!
./functional -i "vale0:v0/z" -r "${len}:${fill}:${num}" &>/dev/null
e4=$?
wait $p3
e3=$?
check_exit $e3 "receive-${num} vale0:v0"
check_exit $e4 "receive-${num} vale0:v0/z"

echo "Test successful."