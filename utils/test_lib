#!/usr/bin/env bash
################################################################################
# Closes the file descriptor server.
# Arguments:
#   None
################################################################################
function close_fd_server() {
	./functional -c &>/dev/null
	check_exit $? "close_fd_server"
}

################################################################################
# Starts the file descriptor server.
# Arguments:
#   None
################################################################################
function start_fd_server() {
	./functional -o &>/dev/null
	check_exit $? "start_fd_server"
}

################################################################################
# Restarts the file descriptor server.
# Arguments:
#   None
################################################################################
function restart_fd_server() {
	close_fd_server
	start_fd_server
}

################################################################################
# Checks the exit value, if it's != 0 cleans up and terminates the script.
# Arguments:
#   $1 -> exit value to check
#   $2 -> string printed
################################################################################
function check_exit() {
	local exit_value="$1"
	local string_to_print="$2"

	if [ $exit_value != 0 ] ; then
		echo "$string_to_print FAIL($exit_value)."
		exit 1
	# else
		# echo "$2 was successful."
	fi
}

################################################################################
# Set a trap while maintaining the one currently set. The new one will be
# executed first.
# Arguments:
#   $1 -> new command to execute during the trap
#   $2 -> signal to trap
################################################################################
function cumulative_trap() {
	local new_command="$1"
	local signal="$2"
	local current_command=""

	# If we run "trap -p SIGNAL" in a subshell we read the traps for that
	# subshell, instead of the current one.
	# https://unix.stackexchange.com/a/334593
	shopt -s lastpipe
	trap -p "$signal" | read current_command
	shopt -u lastpipe

	current_command="$(echo $current_command | awk -F\' '{print $2}')"
	new_command="$new_command; $current_command"
	trap "$new_command" "$signal"
}

################################################################################
# Creates a VALE persistent port and sets a cleanup handler which will be
# called when the script exits.
# Arguments:
#   $1 -> name of the VALE persistent port
#   $2 -> name of the VALE switch that the port will be to be attached to
################################################################################
function create_vale_persistent_port() {
	local if_name="$1"
	local bdg_name="$2"

	vale-ctl -n "$if_name"
	check_exit $? "create $if_name"
	cumulative_trap "vale-ctl -r $if_name" "EXIT"
	check_exit $? "trap-remove $if_name"

	vale-ctl -a "$bdg_name:$if_name"
	check_exit $? "attach $bdg_name:$if_name"
	cumulative_trap "vale-ctl -d $bdg_name:$if_name" "EXIT"
	# We first need to close the file descriptor of the interface, otherwise
	# the detach will fail. To accomplish that we shut down fd_server.
	cumulative_trap "close_fd_server" "EXIT"
	check_exit $? "trap-detach $bdg_name:$if_name"
}

################################################################################
# Creates a pair of veth interfaces and sets a cleanup handler which will be
# called when the script exits.
# Arguments:
#   $1 -> base name of the veth devices
################################################################################
function create_veth_interfaces() {
	local if_name="$1"
	local if_name1="${if_name}A"
	local if_name2="${if_name}B"

	ip link add "$if_name1" type veth peer name "$if_name2"
	check_exit $? "create $if_name"
	# We first need to close the file descriptor of the interfaces,
	# otherwise the delete will fail. To accomplish that we shut down
	# fd_server.
	cumulative_trap "ip link delete $if_name1" "EXIT"
	check_exit $? "trap-delete $if_name1"
	cumulative_trap "close_fd_server" "EXIT"
	check_exit $? "trap-detach $bdg_name:$if_name"
}



################################################################################
# Prints general tests usage.
# Arguments:
#   None
################################################################################
function parse_arguments_usage() {
	echo "usage: [-h] "
	echo "       [-l packet_length]"
	echo "       [-f fill_character]"
	echo "       [-n packets_to_send]"
}


################################################################################
# Parse the command line arguments of the calling script.
# Arguments:
#   It must be always called like like this 'parse_arguments "$@"'
################################################################################
function parse_arguments() {
	while getopts "hl:f:n:" opt; do
		case $opt in
			l) len="$OPTARG"
			;;
			f) fill="$OPTARG"
			;;
			n) num="$OPTARG"
			;;
			h) parse_arguments_usage ; exit 0
			;;
			\?) parse_arguments_usage ; exit 1
			;;
		esac
	done
}