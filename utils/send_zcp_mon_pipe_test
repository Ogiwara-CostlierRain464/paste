#!/usr/bin/env bash
################################################################################
# Test objective: check if a zero-copy monitor is correctly blocked until the
#                 monitored VALE pipe reads the frame.
# Operations:
# 0) restart fd_server to have a clean starting state
# 1) create a pair of VALE pipes (pipe{1, pipe}1).
# 2) open a zero-copy monitor pipe{1/z for pipe{1.
# 3) send from pipe{1 without receiving from pipe{1/z, check that pipe}1 doesn't
#    receive the frame.
# 4) receive from pipe{1/z, check that pipe}1 receives the frame.
################################################################################
source test_lib

restart_fd_server

# Pre-opening interface that will be needed. This is needed to avoid a race
# condition between the sending and receiving ports.
./functional -i "netmap:pipe{1"   &>/dev/null
check_exit $? "pre-open netmap:pipe{1"
./functional -i "netmap:pipe{1/z" &>/dev/null
check_exit $? "pre-open netmap:pipe{1/z"
./functional -i "netmap:pipe}1"   &>/dev/null
check_exit $? "pre-open netmap:pipe}1"

# Initially we don't receive with the monitor, therefore the other end of the
# pipe should not receive the frame.
./functional -i netmap:pipe{1/z -r 150:d -n &>/dev/null &
p1=$!
./functional -i netmap:pipe{1   -t 150:d    &>/dev/null
e2=$?
wait $p1
e1=$?
check_exit $e1 "no-receive netmap:pipe{1/z"
check_exit $e2 "send netmap:pipe{1"

# Now we receive with the monitor, therefore the other end of the pipe should
# receive the frame.
./functional -i "netmap:pipe{1/z" -r 150:d &>/dev/null &
p3=$!
./functional -i "netmap:pipe}1"   -r 150:d &>/dev/null
e4=$?
wait $p3
e3=$?
check_exit $e3 "receive netmap:pipe{1/z"
check_exit $e4 "receive netmap:pipe}1"

echo "Test successful."